<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-10-31T02:10:14+00:00</updated><id>/</id><title type="html">Akas Blog</title><subtitle>The machine learning enginner</subtitle><entry><title type="html">JAVA 바이트코드(bytecode) 정리</title><link href="/JAVA_Byte_Code" rel="alternate" type="text/html" title="JAVA 바이트코드(bytecode) 정리" /><published>2019-10-30T09:00:00+00:00</published><updated>2019-10-30T09:00:00+00:00</updated><id>/JAVA_Byte_Code</id><content type="html" xml:base="/JAVA_Byte_Code">&lt;p&gt;해당 포스트는 “이상현”님의 자바 바이트코드 소개를 참고하여, 작성되었습니다.&lt;/p&gt;
&lt;h1 id=&quot;java-바이트-코드-소개&quot;&gt;JAVA 바이트 코드 소개&lt;/h1&gt;

&lt;h2 id=&quot;컴파일러&quot;&gt;컴파일러&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;자바 바이트 코드는 JVM(Java Virtual Machine)이 실행하는 명령어 집합입니다. 컴파일을 하면 생성되는 .class 파일이 바이트 코드를 담고 있습니다.&lt;/li&gt;
  &lt;li&gt;컴파일을 통해 생성 된 파이트 코드 파일은 OS나 개발환경에 관계없이 같은 명령어 집합을 사용하며, 이것이 자바의 크로스 플랫폼 동작을 가능하게 해줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/JVM3.jpg&quot; alt=&quot;JVM 구조&quot; title=&quot;바이트코드 실행 과정&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;바이트코드 실행 과정에서 두 종류의 컴파일러가 있습니다.
    &lt;ul&gt;
      &lt;li&gt;첫번째 컴파일러는 자바 코드를 자바 클래스 파일로 만들어주는 컴파일러입니다.
        &lt;ul&gt;
          &lt;li&gt;javac로 표기된 부분으로써, JDK(Java Development Kit)에 포함된 기본 컴파일러입니다.&lt;/li&gt;
          &lt;li&gt;해당 작업 이후에, JRE(Java Runtime Environment)에서 더 나은 최적화를 하기 위해, 이후에 loop unrolling, algebraic simplicatin, strength reduction 같은 기본적인 최적화도 하지 않습니다.&lt;/li&gt;
          &lt;li&gt;두번째 컴파일러는 JIT(Just In Time) 컴파일러로써, JVM은 동적으로 바이트코드를 읽으며 인터프리팅을 하는데, 이 단계에서 JIT 컴파일러는 자바 애플리케이션의 성능향상을 위해, 동적 컴파일을 통해 머신 코드(Machine Code)로 컴파일 가능한 코드들을 한 번 더 컴파일합니다.
            &lt;ul&gt;
              &lt;li&gt;미리 컴파일 하지 않고, 실행 중에 동적으로 컴파일 작업을 수행합니다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Akas</name></author><category term="JAVA" /><summary type="html">해당 포스트는 “이상현”님의 자바 바이트코드 소개를 참고하여, 작성되었습니다. JAVA 바이트 코드 소개</summary></entry><entry><title type="html">Git Branch 정리</title><link href="/Git2" rel="alternate" type="text/html" title="Git Branch 정리" /><published>2019-10-11T09:00:00+00:00</published><updated>2019-10-11T09:00:00+00:00</updated><id>/Git2</id><content type="html" xml:base="/Git2">&lt;h1 id=&quot;branch&quot;&gt;Branch&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Git을 초기화 명령을 통해, master branch가 생성된다. 개발중에 새롭게 구현하거나 코드를 작성할 경우, 각각의 기능을 Feature라고 부른다.&lt;/li&gt;
  &lt;li&gt;각각에 새로운 branch를 만들어서, 개별적으로 개발을 진행하고, master branch에 merge를 하여, 협업을 이루어 나간다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;branch-명령어-정리&quot;&gt;Branch 명령어 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;전체 branch 목록 확인하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git branch &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;branch 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git branch &amp;lt;branch_Name&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;branch 이름 바꾸기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git branch &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &amp;lt;new_branch_Name&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;branch 삭제하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;// d옵션은 안전하게 브랜치를 삭제 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;merge 명령어가 적용이 되지 않고 남은 변경 사항이 있다면 삭제하지 않는다.&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
git branch &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &amp;lt;branch&amp;gt;

// D옵션은 merge 되지 않은 변경 사항이 있어도 삭제해버린다&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;force 기능&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
git branch &lt;span class=&quot;nt&quot;&gt;-D&lt;/span&gt; &amp;lt;branch&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;branch 이동하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git checkout master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;새로운 branch를 checkout 명령어로 생성하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git checkout &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; &amp;lt;new_branch_Name&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>Akas</name></author><category term="CI" /><summary type="html">Branch Git을 초기화 명령을 통해, master branch가 생성된다. 개발중에 새롭게 구현하거나 코드를 작성할 경우, 각각의 기능을 Feature라고 부른다. 각각에 새로운 branch를 만들어서, 개별적으로 개발을 진행하고, master branch에 merge를 하여, 협업을 이루어 나간다.</summary></entry><entry><title type="html">JAVA의 Iterator와 enumerate 정리</title><link href="/Synchronous-Asychronous" rel="alternate" type="text/html" title="JAVA의 Iterator와 enumerate 정리" /><published>2019-10-02T09:00:00+00:00</published><updated>2019-10-02T09:00:00+00:00</updated><id>/Synchronous-Asychronous</id><content type="html" xml:base="/Synchronous-Asychronous">&lt;h1 id=&quot;synchronous동기-vs-asynchronous비동기&quot;&gt;Synchronous(동기) VS Asynchronous(비동기)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;동기(Synchronous)는 어떤 작업이 실행되고, 그 작업이 완료될 때까지 다른 작업을 수행할 수가 없다. 이전의 작업이 완료되어야, 다음의 작업을 수행할 수 있다.&lt;/li&gt;
  &lt;li&gt;하지만 비동기(Asynchronous)는 하나의 작업 수행이 완료되지 않아도, 기다리지 않고 다음 작업을 실행한다. 다만 이전부터 수행하고 있던 작업들이 끝나면, 신호를 알려준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;asynchronous-programming-비동기-프로그래밍과-asyncioasyncio&quot;&gt;Asynchronous programming (비동기 프로그래밍)과 AsyncioAsyncio&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;AsyncioAsyncio는 async/await 문법을 사용해 동시성(Concurrent) 코드를 사용할 수 있게 해주는 라이브러리이다.&lt;/li&gt;
  &lt;li&gt;대표적인 장점으로는 시간이 오래 걸리는 작업을 실행했을 때, 결과를 기다리지 않고, 다음 작업을 실행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;java-iterator&quot;&gt;Java Iterator&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Iterator는 반복자라는 뜻으로, Iterator 인터페이스는 자료를 얻어내는데 사용된다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;iterator() 메소드는 컬렉션(Collection) 자료형이라면 관계없이 사용가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;For문을 통해 충분히 자료들을 꺼내올 수 있는데, 굳이 Iterator를 사용하는 이유가 무엇일까?&lt;/li&gt;
  &lt;li&gt;Ans) ArrayList에 담긴 데이터를 Set으로 옮겼다면, 일반적으로 출력문까지 전면 수정이 필요하지만, Iterator는 데이터를 빼오는 방식을 표준화하는데 목적이 있기 때문에, 코드의 재활용이 가능하다(다형성)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iterator-인터페이스에서-사용되는-메소드&quot;&gt;Iterator 인터페이스에서 사용되는 메소드&lt;/h2&gt;
&lt;h3 id=&quot;hasnext&quot;&gt;hasNext()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;뒤에 남은 데이터가 있다면 True, 없다면 False를 반환한다. while 루프를 통한 제어처리시 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;next&quot;&gt;next()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;자료구조의 다음 데이터를 반환하여, 다음 객체의 레퍼런스를 얻는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;remove&quot;&gt;remove()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;현재 조회하는 객체의 레퍼런스를 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;enumeration&quot;&gt;Enumeration&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Enumeration은 Iterator에서 remove() 메소드만 빠지고, 이름만 다를 뿐 사용법은 같다. (Iterator의 구버전)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;enumeration의-메소드&quot;&gt;Enumeration의 메소드&lt;/h2&gt;
&lt;h3 id=&quot;hasmoreelements&quot;&gt;hasMoreElements()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Iterator의 .hasNext()와 같은 기능이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nextelement&quot;&gt;nextElement()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Iterator의 next()와 같은 기능이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;listiterator&quot;&gt;ListIterator&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;ListIterator는 Iterator를 상속받아서 기능을 추가한 것이다.&lt;/li&gt;
  &lt;li&gt;컬렉션의 요소에 접근할 때, Iterator는 단방향으로만 이동할 수 있지만, ListIterator는 양방향으로 이동이 가능하다는 장점이 있다.&lt;/li&gt;
  &lt;li&gt;ArrayList나 LinkedList처럼 List 인터페이스를 구현한 컬렉션 클래스에서만 사용이 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fail-fast-방식&quot;&gt;Fail-Fast 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Iterator를 이용해서 순차적으로 접근하고 있는 도중 다른 곳에서 해당 컬렉션에 데이터를 추가하거나 삭제하는 등의 작업이 일어난다면, ConcurrentModificationException이 발생하게 하는 방식
(Java 1.2 부터 지원)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Enumeration은 컬렉션의 집합을 통째로 복사해서(Snapshot) 사용하기 때문에 Fail-Fast를 지원하지 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Iterator는 데이터의 안정성을 보장한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Akas</name></author><category term="JAVA" /><summary type="html">Synchronous(동기) VS Asynchronous(비동기) 동기(Synchronous)는 어떤 작업이 실행되고, 그 작업이 완료될 때까지 다른 작업을 수행할 수가 없다. 이전의 작업이 완료되어야, 다음의 작업을 수행할 수 있다. 하지만 비동기(Asynchronous)는 하나의 작업 수행이 완료되지 않아도, 기다리지 않고 다음 작업을 실행한다. 다만 이전부터 수행하고 있던 작업들이 끝나면, 신호를 알려준다.</summary></entry><entry><title type="html">Parallel SSH</title><link href="/PSSH" rel="alternate" type="text/html" title="Parallel SSH" /><published>2019-09-24T09:00:00+00:00</published><updated>2019-09-24T09:00:00+00:00</updated><id>/PSSH</id><content type="html" xml:base="/PSSH">&lt;p&gt;다수의 타깃서버에 동일한 명령, 파일복제 등을 수행할때 PSSH, PSCP 등을 활용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;명령어-설명&quot;&gt;명령어 설명&lt;/h2&gt;
&lt;p&gt;PSSH(Parallel-SSH) : 여러 대의 서버에 동일한 명령어를 반복 적용할 수 있는 명령어
PSCP(Parallel-SCP) : 여러 대의 서버에 동일한 파일을 반복하여 복사할 수 있는 명령어
Usage: pssh/pscp (options) command
Options
-i : 결과 출력
-h : 호스트 파일 불러오기
-H : 목적지 주소 기재(ip, hostname, domain 입력), 2개 이상의 서버에 명령할 경우 띄어주기로 구분&lt;/p&gt;

&lt;h2 id=&quot;pssh-예제&quot;&gt;PSSH 예제&lt;/h2&gt;
&lt;p&gt;3.1 PSSH를 활용하여, 여러 서버의 비밀번호 변경하기
타깃 서버 리스트 작성 (-h 옵션 사용시)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동시에 명령을 수행 할 서버의 정보를 등록해준다(4가지 방식 가능)&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# ip:port 형식&lt;/span&gt;
0.0.0.1:1111
0.0.0.2:1111

&lt;span class=&quot;c&quot;&gt;# hostname:port 형식&lt;/span&gt;
hostname1:1111
hostname2:1111

&lt;span class=&quot;c&quot;&gt;# IP (사용자가 직접 SSH 서비스의 포트를 설정하면, 포트명을 생략하여 사용할 수 있다.)&lt;/span&gt;
0.0.0.1
0.0.0.2

&lt;span class=&quot;c&quot;&gt;# HostName&lt;/span&gt;
hostname1
hostname2&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;hosts에 등록 된 여러 서버의 비밀번호를 한번에 변경할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;호스트-리스트에-작성된-타깃서버들에-동일하게-password-변경-적용&quot;&gt;호스트 리스트에 작성된 타깃서버들에 동일하게 PASSWORD 변경 적용&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;pssh &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; hosts.list &lt;span class=&quot;s2&quot;&gt;&quot;echo 'PASSWORD' | sudo passwd --stdin hdfs&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;32-pscp로-파일-배포하기&quot;&gt;3.2 PSCP로 파일 배포하기&lt;/h2&gt;
&lt;p&gt;PSCP예시 : pscp [OPTIONS] 로컬파일의위치 복제할위치
PSCP 명령어는 PSSH 명령어와는 달리, “sudo” 명령어 사용에 제약(권한 제한)이 있어 /etc/hosts로 바로 이동을 시킬 수 없어 (pscp로 복제가능한 경로인) /home/hdfs에 우선 복사한 후, 옮기는 방식을 사용한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# 호스트 리스트에 작성된 타깃서버들에 파일복제 수행&lt;/span&gt;
pscp &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; hosts.list /etc/hosts /home/hdfs


/etc/hosts에 옮겨준다.

pssh &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; hosts.list &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;mv /home/hdfs/hosts /etc/hosts&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>Akas</name></author><category term="Linux" /><summary type="html">다수의 타깃서버에 동일한 명령, 파일복제 등을 수행할때 PSSH, PSCP 등을 활용할 수 있다.</summary></entry><entry><title type="html">Git Workflow</title><link href="/git" rel="alternate" type="text/html" title="Git Workflow" /><published>2019-09-19T09:00:00+00:00</published><updated>2019-09-19T09:00:00+00:00</updated><id>/git</id><content type="html" xml:base="/git">&lt;h1 id=&quot;svn과-git-차이점-요약&quot;&gt;SVN과 Git 차이점 요약&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;저장소의 위치가 다르며, 로컬 저장소가 존재한다.(분산 처리, 안전성, 빠른 속도)&lt;/li&gt;
  &lt;li&gt;커밋 이전에 스테이지 영역에 추가하는 과정이 존재(커밋 대상의 분리)&lt;/li&gt;
  &lt;li&gt;각각의 버전을 스냅샷으로 저장&lt;/li&gt;
  &lt;li&gt;스냅샷이 존재하기 때문에 브랜치도 자유롭게 생성 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;git의-주요-명령어-정리&quot;&gt;Git의 주요 명령어 정리&lt;/h1&gt;

&lt;h2 id=&quot;새로운-저장소-만들기&quot;&gt;새로운 저장소 만들기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;폴더를 만들고 그 안에서 새로운 git 저장소(.git)를 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git init&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;변경내용-확정하기&quot;&gt;변경내용 확정하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스테이징(Staging) 영역에 추가 된 변경 내용을 확정하기 위해, Commit 명령어를 이용&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;DESCRIPTION&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;변경-내용-발행하기&quot;&gt;변경 내용 발행하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;원격 저장소에 변경 내용을 올리는 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git push origin master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;기존의 remote가 아닌, 원격 저장소의 주소를 바꿔서 발행하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git remote add origin &amp;lt;원격서버주소&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h1 id=&quot;저장소-받아오기&quot;&gt;저장소 받아오기&lt;/h1&gt;
&lt;h2 id=&quot;로컬-저장소local-repository에-복제하기&quot;&gt;로컬 저장소(Local repository)에 복제하기&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone &lt;span class=&quot;s2&quot;&gt;&quot;/path&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;원격-서버의-저장소를-복제하기&quot;&gt;원격 서버의 저장소를 복제하기&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone 사용자명@호스트:/원격/저장소/경로&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;브랜치-관리하기&quot;&gt;브랜치 관리하기&lt;/h2&gt;

&lt;h3 id=&quot;브랜치-만들기&quot;&gt;브랜치 만들기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;develop이라는 이름의 브랜치를 생성한 후, 해당 디렉토리로 이동&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git checkout &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; develop&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;다시 Master로 돌아오기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git checkout master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;갱신하고-병합하기&quot;&gt;갱신하고 병합하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;로컬 저장소를 원격 저장소에 맞추어서 업데이트 및 갱신하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git pull&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;다른 브랜치의 변경 내용을 현재 브랜치에 병합하기 (현재 Branch 폴더 내에서 명령어를 수행)&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git merge &amp;lt;Branch 이름&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;브랜치-삭제-및-원격-저장소-전송&quot;&gt;브랜치 삭제 및 원격 저장소 전송&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;develop 브랜치를 삭제하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git branch &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; develop&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;원격 저장소로 브랜치 전송하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git push origin develop&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;변경-내용-되돌리기&quot;&gt;변경 내용 되돌리기.&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;한 단계 전 상태로 돌아가기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git reset HEAD~1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;해당 커밋을 되돌리는 커밋을 새로 생성하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git revert&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;해당 정리는 Aria(In Suk) Kim님의 Git-Workflow를 참고하여, 작성한 포스트입니다.
참조 url : https://www.slideshare.net/shoo7830/gitworkflow-170728162&lt;/p&gt;</content><author><name>Akas</name></author><category term="CI" /><summary type="html">SVN과 Git 차이점 요약 저장소의 위치가 다르며, 로컬 저장소가 존재한다.(분산 처리, 안전성, 빠른 속도) 커밋 이전에 스테이지 영역에 추가하는 과정이 존재(커밋 대상의 분리) 각각의 버전을 스냅샷으로 저장 스냅샷이 존재하기 때문에 브랜치도 자유롭게 생성 가능</summary></entry><entry><title type="html">JAVA의 다형성(Polymorphism)과 동적바인딩</title><link href="/Polymorphism_Dynamic_Binding" rel="alternate" type="text/html" title="JAVA의 다형성(Polymorphism)과 동적바인딩" /><published>2019-09-17T09:00:00+00:00</published><updated>2019-09-17T09:00:00+00:00</updated><id>/Polymorphism_Dynamic_Binding</id><content type="html" xml:base="/Polymorphism_Dynamic_Binding">&lt;h1 id=&quot;다형성&quot;&gt;다형성&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;“객체지향”에는 4가지 중요한 개념이 있다. 추상화, 캡슐화, 상송 그리고 다형성이다.&lt;/li&gt;
  &lt;li&gt;아래의 코드를 통해, 다형성 및 동적 바인딩의 개념을 살펴보자.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Polymorphism&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Person&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Student&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;참조 변수 student는 Person 객체를 참조하고 있다. 따라서, Person 내의 show() 메소드가 호출이 되어야하지만, 동적바인딩을 통해 런타임 시점에 객체 타입을 기준으로 실행될 함수를 호출한다.
즉 실행되는 시점에서는  Student 객체가 생성되어, 해당 객체의 show() 함수를 호출한다.&lt;/p&gt;

&lt;p&gt;정리하자면, 다형성이 적용될 때, 참조 변수 student는 컴파일 시점과 런타임 시점에서 참조하는 함수가 다른 것이다.&lt;/p&gt;

&lt;p&gt;게시글 참조 : https://brunch.co.kr/@mystoryg/60&lt;/p&gt;</content><author><name>Akas</name></author><category term="Java" /><summary type="html">다형성 “객체지향”에는 4가지 중요한 개념이 있다. 추상화, 캡슐화, 상송 그리고 다형성이다. 아래의 코드를 통해, 다형성 및 동적 바인딩의 개념을 살펴보자.</summary></entry><entry><title type="html">/etc/hosts 설정</title><link href="/Linux-hosts" rel="alternate" type="text/html" title="/etc/hosts 설정" /><published>2019-09-11T09:00:00+00:00</published><updated>2019-09-11T09:00:00+00:00</updated><id>/Linux-hosts</id><content type="html" xml:base="/Linux-hosts">&lt;h1 id=&quot;호스트-파일-설정&quot;&gt;호스트 파일 설정&lt;/h1&gt;
&lt;h2 id=&quot;hosts-파일-소개&quot;&gt;hosts 파일 소개&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;/etc/hosts 파일에 리눅스 로컬네임서버 설정을 할 수 있다.&lt;/li&gt;
  &lt;li&gt;리눅스에서 hosts의 내용은 DNS(Domain Name Server)보다 먼저 탐색되어, 호스트명을 IP 주소로 풀어서 해석한다.&lt;/li&gt;
  &lt;li&gt;“NAVER” 서비스를 이용할 때, “NAVER”의 IP 주소를 입력하는 것이 아니라, 도메인명을 활용하여 서비스를 이용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;호스트hosts-설정&quot;&gt;호스트(hosts) 설정&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;/etc/hosts 파일을 편집한다.&lt;/li&gt;
  &lt;li&gt;각 서버들의 IP 주소 및 도메인명과 Alias 등의 정보를 넣어준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# hosts 설정 방법&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@admin ~]# vi /etc/hosts
101.101.101.101 test1.도메인명.com test1 &lt;span class=&quot;c&quot;&gt;# IP주소 도메인명 Alias(도메인의 별칭) 순으로 입력&lt;/span&gt;
101.101.101.102 test2.도메인명.com test2
101.101.101.103 test3.도메인명.com test3
101.101.101.104 test4.도메인명.com test4&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# 도메인명으로 PING TEST&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@admin ~]# ping test1.도메인명.com
PING test1.도메인명.com &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;101.101.101.101&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 4&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;8&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; bytes of data.

&lt;span class=&quot;c&quot;&gt;# ALIAS로 PING TEST&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@admin ~]# ping test1
PING test1 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;101.101.101.101&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 56&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;84&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; bytes of data.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;호스트명-변경&quot;&gt;호스트명 변경&lt;/h2&gt;
&lt;h3 id=&quot;hostnamectl-명령어를-활용하는-방법&quot;&gt;hostnamectl 명령어를 활용하는 방법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Network hostname을 test.domainName.com으로 설정&lt;/li&gt;
  &lt;li&gt;Home 디렉토리에서 작업을 수행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@admin ~]# &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;hostnamectl set-hostname test.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# 변경 된 호스트명을 확인할 수 있다.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@admin ~]# hostname&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# 출력 결과&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@admin ~]# test1.도메인명.com&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;shell-script를-활용하여-호스트-이름을-변경하는-방법&quot;&gt;Shell script를 활용하여, 호스트 이름을 변경하는 방법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;bash 파일을 활용하여, 전체 서버에 명령어를 전달하려고 한다. change_hosts_name.sh 이름의 bash 파일을 생성해보자.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# bash 파일을 실행하여, 리눅스 터널링을 수행할 것이다.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@admin ~]# vi change_hosts_name.sh&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;host 안에는 hostname 목록들이 존재하며, 아래의 내용을 change_hosts_name.sh 파일에 넣어줌으로써, bash 파일을 수정해준다.&lt;/li&gt;
  &lt;li&gt;내용 수정이 끝난 후에는 vi 명령어를 통해 쓰기 후 저장을 한다.(ESC키 → :wq 입력 후 엔터키로 빠져나온다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;host &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;hosts&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do
    &lt;/span&gt;ssh &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;portNumber&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;userName&quot;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'@'&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$host&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;hostnamectl set-hostname &lt;span class=&quot;nv&quot;&gt;$host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;bash 파일을 실행해준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@admin ~]# sh ./change_hosts_name.sh&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>Akas</name></author><category term="Linux" /><summary type="html">호스트 파일 설정 hosts 파일 소개 /etc/hosts 파일에 리눅스 로컬네임서버 설정을 할 수 있다. 리눅스에서 hosts의 내용은 DNS(Domain Name Server)보다 먼저 탐색되어, 호스트명을 IP 주소로 풀어서 해석한다. “NAVER” 서비스를 이용할 때, “NAVER”의 IP 주소를 입력하는 것이 아니라, 도메인명을 활용하여 서비스를 이용한다.</summary></entry><entry><title type="html">JAVA의 length, length(), size 비교</title><link href="/%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98Versus%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98" rel="alternate" type="text/html" title="JAVA의 length, length(), size 비교" /><published>2019-09-11T09:00:00+00:00</published><updated>2019-09-11T09:00:00+00:00</updated><id>/%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98Versus%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98</id><content type="html" xml:base="/%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98Versus%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98">&lt;h1 id=&quot;지역변수-및-전역변수-신중하게-사용하기&quot;&gt;지역변수 및 전역변수 신중하게 사용하기.&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;지역 변수와 전역 변수를 구분하는 기준은, 변수를 블록 내(if, for 구문)에서만 사용가능하느냐 아니면 전체에서 사용 가능하느냐의 차이.&lt;/li&gt;
  &lt;li&gt;전역 변수는 블록 내에서 모두 사용가능하지만, 지역 변수로 활용이 되고 있는 부분이 블록 밖에서는 Compile 오류가 발생한다.&lt;/li&gt;
  &lt;li&gt;전역 변수는 함수 밖에서 선언하며, 어디에서든지 접근 가능한 변수.&lt;/li&gt;
  &lt;li&gt;지역 변수는 함수 내에서 선언하며 블록 내에서만 접근 가능한 변수.&lt;/li&gt;
  &lt;li&gt;단 지역변수는 선언한 위치에 따라 접근할 수 있는 (사용할 수 있는) 범위가 달라지기도 한다.&lt;/li&gt;
  &lt;li&gt;일반적인 프로그래밍에서는 곡 필요하지 않다면, 전역 변수는 잘 사용하지 않는다.&lt;/li&gt;
  &lt;li&gt;지역 변수는 함수가 끝나거나 블록을 벗어나면 메모리에서 소멸되는데, 전역 변수는 계속 살아남아있어, 메모리 낭비를 초래할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;problem_solving에서-컴파일-오류가-발생했던-부분&quot;&gt;Problem_Solving에서 컴파일 오류가 발생했던 부분&lt;/h1&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Serial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9600&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Serial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Serial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; - &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Serial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;결론: 전역 변수와 지역 변수를 구분하려고 하였으나, 변수 a를 이미 전역 변수로 선언을 하였는데, 지역 변수를 한번 더 선언을 하여 오류 발생.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Akas</name></author><category term="JAVA" /><summary type="html">지역변수 및 전역변수 신중하게 사용하기. 지역 변수와 전역 변수를 구분하는 기준은, 변수를 블록 내(if, for 구문)에서만 사용가능하느냐 아니면 전체에서 사용 가능하느냐의 차이. 전역 변수는 블록 내에서 모두 사용가능하지만, 지역 변수로 활용이 되고 있는 부분이 블록 밖에서는 Compile 오류가 발생한다. 전역 변수는 함수 밖에서 선언하며, 어디에서든지 접근 가능한 변수. 지역 변수는 함수 내에서 선언하며 블록 내에서만 접근 가능한 변수. 단 지역변수는 선언한 위치에 따라 접근할 수 있는 (사용할 수 있는) 범위가 달라지기도 한다. 일반적인 프로그래밍에서는 곡 필요하지 않다면, 전역 변수는 잘 사용하지 않는다. 지역 변수는 함수가 끝나거나 블록을 벗어나면 메모리에서 소멸되는데, 전역 변수는 계속 살아남아있어, 메모리 낭비를 초래할 수 있다.</summary></entry><entry><title type="html">JAVA의 length, length(), size 비교</title><link href="/Size_Length" rel="alternate" type="text/html" title="JAVA의 length, length(), size 비교" /><published>2019-09-11T09:00:00+00:00</published><updated>2019-09-11T09:00:00+00:00</updated><id>/Size_Length</id><content type="html" xml:base="/Size_Length">&lt;h1 id=&quot;java의-length-length-size-사용-및-비교&quot;&gt;JAVA의 LENGTH, LENGTH(), SIZE 사용 및 비교&lt;/h1&gt;

&lt;h2 id=&quot;length&quot;&gt;length&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;arrays (int[], double[], String[]) : 배열의 길이를 알려 할때 사용한다.&lt;/li&gt;
  &lt;li&gt;메소드가 아니므로, Object로 사용하지 않는다. 따라서 오직 배열에서만 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;length-1&quot;&gt;length()&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;String related Object (String, StringBuilder etc) : 이것은 문자열의 길이를 알고자 할때 사용된다.&lt;/li&gt;
  &lt;li&gt;스트링은 배열이 아니므로, .length를 사용할 수 없으며, 컬렉션 또한 아니기 때문에, .size() 도 사용할 수 없다. 이를 위해 length()가 설계되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;size&quot;&gt;size()&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Collection Object (ArrayList, Set etc) : 컬렉션 타입의 길이를 확인할때 사용된다.&lt;/li&gt;
  &lt;li&gt;메소드이므로, Collection에 사용될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;지역변수-및-전역변수-신중하게-사용하기&quot;&gt;지역변수 및 전역변수 신중하게 사용하기.&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;지역 변수와 전역 변수를 구분하는 기준은, 변수를 블록 내(if, for 구문)에서만 사용가능하느냐 아니면 전체에서 사용 가능하느냐의 차이.&lt;/li&gt;
  &lt;li&gt;전역 변수는 블록 내에서 모두 사용가능하지만, 지역 변수로 활용이 되고 있는 부분이 블록 밖에서는 Compile 오류가 발생한다.&lt;/li&gt;
  &lt;li&gt;전역 변수는 함수 밖에서 선언하며, 어디에서든지 접근 가능한 변수.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Akas</name></author><category term="JAVA" /><summary type="html">JAVA의 LENGTH, LENGTH(), SIZE 사용 및 비교</summary></entry><entry><title type="html">Stack 과 Queue 정리</title><link href="/Stack_Queue" rel="alternate" type="text/html" title="Stack 과 Queue 정리" /><published>2019-09-11T09:00:00+00:00</published><updated>2019-09-11T09:00:00+00:00</updated><id>/Stack_Queue</id><content type="html" xml:base="/Stack_Queue">&lt;h1 id=&quot;stack&quot;&gt;Stack&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;한 쪽 끝에서만 자료를 넣고 뺄 수 있는 자료 구조.&lt;/li&gt;
  &lt;li&gt;마지막으로 넣은 것이 가장 먼저 나오기 때문에 Last In First Out (LIFO) 라고 한다.&lt;/li&gt;
  &lt;li&gt;“스택”에서 데이터가 들어가고 나가는 곳을 “한 지점”에 고정을 시켜놓고, 명령어를 수행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;stack-명령어-정리&quot;&gt;Stack 명령어 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;push : 스택에 자료를 넣는 연산&lt;/li&gt;
  &lt;li&gt;pop : 스택에 자료를 빼는 연산&lt;/li&gt;
  &lt;li&gt;top : 스택의 가장 위에 있는 자료를 보는 연산&lt;/li&gt;
  &lt;li&gt;empty : 스택이 비어있는지 아닌지를 알아보는 연산&lt;/li&gt;
  &lt;li&gt;size : 스택에 저장되어 있는 자료의 개수를 알아보는 연산&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;대표-문제-유형&quot;&gt;대표 문제 유형&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;괄호 문제(짝 맞추기 문제)&lt;/li&gt;
  &lt;li&gt;스택 수열&lt;/li&gt;
  &lt;li&gt;단어 뒤집기&lt;/li&gt;
  &lt;li&gt;에디터 문제&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;queue&quot;&gt;Queue&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;한 쪽 끝에서만 자료를 넣고, 다른 한 쪽 끝에서만 뺄 수 있는 자료 구조&lt;/li&gt;
  &lt;li&gt;먼저 넣은 것이 가장 먼저 나오기 때문에 First In First Out(FIFO) 라고 한다.&lt;/li&gt;
  &lt;li&gt;삭제 연산은 Begin 쪽에, 삽입 연산은 End 쪽에서 이루어진다.&lt;/li&gt;
  &lt;li&gt;C++의 경우에는 STL의 queue를 사용하고, Java의 경우에는 java.util.Queue를 사용하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;queue-명령어-정리&quot;&gt;Queue 명령어 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;push : 큐에 자료를 넣는 연산&lt;/li&gt;
  &lt;li&gt;pop : 큐에서 자료를 빼는 연산&lt;/li&gt;
  &lt;li&gt;front : 큐의 가장 앞에 있는 자료를 보는 연산&lt;/li&gt;
  &lt;li&gt;back : 큐의 가장 뒤에 있는 자료를 보는 연산&lt;/li&gt;
  &lt;li&gt;empty : 큐가 비어있는지 아닌지를 알아보는 연산&lt;/li&gt;
  &lt;li&gt;size : 큐에 저장되어있는 자료의 개수를 알아보는 연산&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;대표-문제-유형-1&quot;&gt;대표 문제 유형&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;조세퍼스 문제&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;deque-덱&quot;&gt;Deque (덱)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;양 끝에서만 자료를 넣고 양 끝에서 뺄 수 있는 자료구조&lt;/li&gt;
  &lt;li&gt;Double-ended queue의 약자&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;deque-명령어-정리&quot;&gt;Deque 명령어 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;push_front : 큐에 자료를 넣는 연산&lt;/li&gt;
  &lt;li&gt;pop : 큐에서 자료를 넣는 연산&lt;/li&gt;
  &lt;li&gt;front : 큐의 가장 앞에 있는 자료를 보는 연산&lt;/li&gt;
  &lt;li&gt;back : 큐의 가장 뒤에 있는 자료를 보는 연산&lt;/li&gt;
  &lt;li&gt;empty : 큐가 비어있는지 아닌지를 알아보는 연산&lt;/li&gt;
  &lt;li&gt;size : 큐에 저장되어 있는 자료의 개수를 알아보는 연산&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Akas</name></author><category term="DS" /><summary type="html">Stack 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 자료 구조. 마지막으로 넣은 것이 가장 먼저 나오기 때문에 Last In First Out (LIFO) 라고 한다. “스택”에서 데이터가 들어가고 나가는 곳을 “한 지점”에 고정을 시켜놓고, 명령어를 수행한다.</summary></entry></feed>