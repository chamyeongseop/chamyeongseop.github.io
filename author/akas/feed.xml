<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="/author/akas/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/" rel="alternate" type="text/html" />
  <updated>2019-11-07T09:02:14+00:00</updated>
  <id>/author/akas/feed.xml</id>

  
  
  

  
    <title type="html">Akas Blog | </title>
  

  
    <subtitle>The machine learning enginner</subtitle>
  

  

  
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">JAVA Memory 간단 정리</title>
      <link href="/JAVA_Memory" rel="alternate" type="text/html" title="JAVA Memory 간단 정리" />
      <published>2019-10-31T09:00:00+00:00</published>
      <updated>2019-10-31T09:00:00+00:00</updated>
      <id>/JAVA_Memory</id>
      <content type="html" xml:base="/JAVA_Memory">&lt;h1 id=&quot;java-memory&quot;&gt;JAVA Memory&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;JAVA 8을 기준으로 JVM 메모리 영역에 변화(Metaspace 등장)가 있었으며, JAVA Memory의 구성요소들을 살펴보자.&lt;/li&gt;
  &lt;li&gt;JAVA Memory 영역은 Runtime Data Area라고 불리우며, 여러 영역으로 나누어져 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;method-area&quot;&gt;Method Area&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;JVM에서 읽은 클래스와 인터페이스 정보가 저장되는 영역으로, 클래스 생성자 및 바이트 코드가 저장된다.&lt;/li&gt;
  &lt;li&gt;Class의 인스턴스가 생성된 후, 메소드가 실행되는 순간, 클래스의 정보가 Method Area에 저장된다.&lt;/li&gt;
  &lt;li&gt;Method Area는 모든 Thread에 의해 공유되는 영역으로써, JVM이 시작될 때 생성된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;method-area---runtime-constant-pool&quot;&gt;Method Area - Runtime Constant Pool&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Method Area는 내부에 Runtime Constant Pool 영역을 가지고 있으며, 해당 영역에는 클래스 및 인터페이스의 메소드, 필드, 문자열 상수 등의 레퍼런스가 저장되며, 이들의 물리적인 메모리 위치를 참조할 경우에 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heap&quot;&gt;Heap&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;new 연산자 등으로 생성 된 객체(인스턴스)와 배열 등이 저장되는 영역이다.&lt;/li&gt;
  &lt;li&gt;Heap 영역에 저장된 객체(인스턴스)나 배열은 다른 객체에서 참조될 수 있다.&lt;/li&gt;
  &lt;li&gt;GC(Garbage Collection)이 발생하는 영역이며, 참조가 없는 객체들은 GC과정을 통해 메모리에서 제거된다.&lt;/li&gt;
  &lt;li&gt;Heap 영역 또한 내부적으로 여러 영역으로 구성되어 있으며, 이는 객체의 lifecycle과 GC와 연관되어 있다.(튜닝 옵션: -Xms, -Xmx)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jvm-language-stacks&quot;&gt;JVM Language Stacks&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;메소드 호출 시 수행 중인 메소드 데이터(지역변수, 지역객체 레퍼런스, 메소드 파라미터, 메소드 리턴값 등)를 저장하기 위한 영역이다.&lt;/li&gt;
  &lt;li&gt;Stack 영역은 Thread 별로 각각 독립적으로 생성된다.&lt;/li&gt;
  &lt;li&gt;Stack 영역에는 메소드 진입시마다 메소드 데이터를 포함하는 Stack Frame이 생성되어 push되며, 메소드 생성이 완료되면, Stack Frame은 pop되어 사라진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pc-registers&quot;&gt;PC Registers&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;각 Thread 마다 할당되는 영역으로, Thread가 시작될 때 생성된다.&lt;/li&gt;
  &lt;li&gt;PC Registers 영역에는 Thrad가 실행할 JVM 명령(바이트 코드 명령)의 주소를 저장하게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;native-method-area는&quot;&gt;Native Method Area는&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;JAVA 외의 언어로 작성된 코드(Native code, JNI로 실해오디는 코드)를 위한 Stack 영영으로, 각 언어에 맞는 Stack이 생성된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/JVM_memory.jpg&quot; alt=&quot;JVM 메모리 구조&quot; title=&quot;JVM Memory 구조&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;heap-영역-자세히-살펴보기&quot;&gt;Heap 영역 자세히 살펴보기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Heap 영역은 new 연산자 등으로 생성 된 객체(인스턴스)와 배열 등을 저장하는 영역으로, GC가 발생한다.&lt;/li&gt;
  &lt;li&gt;GC는 한정적인 메모리 자원을 효율적으로 사용하기 위해, 더 이상 불필요한 리소스들을 메모리에서 제거하는 작업을 의미한다.&lt;/li&gt;
  &lt;li&gt;Heap 영역은 Eden, Suvivorm Old, Permanent 영역으로 구성되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;eden-영역young-영역&quot;&gt;Eden 영역(Young 영역)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;새로 생성 된 대부분의 객체가 처음 위치하는 영역이다.&lt;/li&gt;
  &lt;li&gt;Eden 영역에서는 정기적으로 GC가 발생하며, 이후에 살아남은 객체들은 Suvivor 1 또는 Survivor 2 영역 중 하나의 영역으로 이동하여, 저장된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;survivor-1-survivor-2-영역young-영역&quot;&gt;Survivor 1, Survivor 2 영역(Young 영역)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Survivor 1, Survivor 2 중 하나의 영역이 꽉 차게되면, 그 중 살아남은 객체들은 비워 진 Survivor 영역으로 이동한다. 이동 시, 참조가 없는 객체들은 메모리에서 정리된다.&lt;/li&gt;
  &lt;li&gt;위와 같은 매커니즘으로 인해, Survivor 1 또는 Survivor 2는 항상 비워진 상태가 되며, Survovir 영역 중 하나의 영역이 완전히 비워지지 않았다면, 문제가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;minor-gc&quot;&gt;Minor GC&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Eden 영역 또는 Survivor 영역 등, Young 영역에서 발생하는 GC를 minor GC라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;old-영역&quot;&gt;Old 영역&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Survivor 1, Survivor 2 영역을 왔다갔다 하는 과정에서 끝까지 살아남은 객체만이 Old 영역으로 이동하게 된다.&lt;/li&gt;
  &lt;li&gt;보통 Old 영역은 Young 영역보다 크게 할당하며, 이러한 이유로 Old 영역의 GC는 Young 영역보다 적게 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;major-gc&quot;&gt;Major GC&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Old 영역, Permanent 영역에서 발생하는 GC를 Major GC(Full GC)라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;permanent-영역&quot;&gt;Permanent 영역&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;클래스 로더에 의해 로드 된 클래스들이 저장되는 공간이다. JAVA 8에서는 Permanent 영역이 조금 더 다듬어져서 Metaspace라는 영역으로 교체되었다.&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Akas</name>
        
        
      </author>

      

      
        <category term="JAVA" />
      

      
        <summary type="html">JAVA Memory JAVA 8을 기준으로 JVM 메모리 영역에 변화(Metaspace 등장)가 있었으며, JAVA Memory의 구성요소들을 살펴보자. JAVA Memory 영역은 Runtime Data Area라고 불리우며, 여러 영역으로 나누어져 있다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JAVA 바이트코드(bytecode) 정리</title>
      <link href="/JAVA_Byte_Code" rel="alternate" type="text/html" title="JAVA 바이트코드(bytecode) 정리" />
      <published>2019-10-30T09:00:00+00:00</published>
      <updated>2019-10-30T09:00:00+00:00</updated>
      <id>/JAVA_Byte_Code</id>
      <content type="html" xml:base="/JAVA_Byte_Code">&lt;p&gt;해당 포스트는 “이상현”님의 자바 바이트코드 소개를 참고하여, 작성되었습니다.&lt;/p&gt;
&lt;h1 id=&quot;java-바이트-코드-소개&quot;&gt;JAVA 바이트 코드 소개&lt;/h1&gt;

&lt;h2 id=&quot;컴파일러&quot;&gt;컴파일러&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;자바 바이트 코드는 JVM(Java Virtual Machine)이 실행하는 명령어 집합입니다. 컴파일을 하면 생성되는 .class 파일이 바이트 코드를 담고 있습니다.&lt;/li&gt;
  &lt;li&gt;컴파일을 통해 생성 된 파이트 코드 파일은 OS나 개발환경에 관계없이 같은 명령어 집합을 사용하며, 이것이 자바의 크로스 플랫폼 동작을 가능하게 해줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/JVM3.jpg&quot; alt=&quot;JVM 구조&quot; title=&quot;바이트코드 실행 과정&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;바이트코드 실행 과정에서 두 종류의 컴파일러가 있습니다.
    &lt;ul&gt;
      &lt;li&gt;첫번째 컴파일러는 자바 코드를 자바 클래스 파일로 만들어주는 컴파일러입니다.
        &lt;ul&gt;
          &lt;li&gt;javac로 표기된 부분으로써, JDK(Java Development Kit)에 포함된 기본 컴파일러입니다.&lt;/li&gt;
          &lt;li&gt;해당 작업 이후에, JRE(Java Runtime Environment)에서 더 나은 최적화를 하기 위해, 이후에 loop unrolling, algebraic simplicatin, strength reduction 같은 기본적인 최적화도 하지 않습니다.&lt;/li&gt;
          &lt;li&gt;두번째 컴파일러는 JIT(Just In Time) 컴파일러로써, JVM은 동적으로 바이트코드를 읽으며 인터프리팅을 하는데, 이 단계에서 JIT 컴파일러는 자바 애플리케이션의 성능향상을 위해, 동적 컴파일을 통해 머신 코드(Machine Code)로 컴파일 가능한 코드들을 한 번 더 컴파일합니다.
            &lt;ul&gt;
              &lt;li&gt;미리 컴파일 하지 않고, 실행 중에 동적으로 컴파일 작업을 수행합니다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Akas</name>
        
        
      </author>

      

      
        <category term="JAVA" />
      

      
        <summary type="html">해당 포스트는 “이상현”님의 자바 바이트코드 소개를 참고하여, 작성되었습니다. JAVA 바이트 코드 소개</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Git Branch 정리</title>
      <link href="/Git2" rel="alternate" type="text/html" title="Git Branch 정리" />
      <published>2019-10-11T09:00:00+00:00</published>
      <updated>2019-10-11T09:00:00+00:00</updated>
      <id>/Git2</id>
      <content type="html" xml:base="/Git2">&lt;h1 id=&quot;branch&quot;&gt;Branch&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Git을 초기화 명령을 통해, master branch가 생성된다. 개발중에 새롭게 구현하거나 코드를 작성할 경우, 각각의 기능을 Feature라고 부른다.&lt;/li&gt;
  &lt;li&gt;각각에 새로운 branch를 만들어서, 개별적으로 개발을 진행하고, master branch에 merge를 하여, 협업을 이루어 나간다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;branch-명령어-정리&quot;&gt;Branch 명령어 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;전체 branch 목록 확인하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git branch &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;branch 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git branch &amp;lt;branch_Name&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;branch 이름 바꾸기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git branch &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &amp;lt;new_branch_Name&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;branch 삭제하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;// d옵션은 안전하게 브랜치를 삭제 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;merge 명령어가 적용이 되지 않고 남은 변경 사항이 있다면 삭제하지 않는다.&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
git branch &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &amp;lt;branch&amp;gt;

// D옵션은 merge 되지 않은 변경 사항이 있어도 삭제해버린다&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;force 기능&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
git branch &lt;span class=&quot;nt&quot;&gt;-D&lt;/span&gt; &amp;lt;branch&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;branch 이동하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git checkout master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;새로운 branch를 checkout 명령어로 생성하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git checkout &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; &amp;lt;new_branch_Name&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content>

      
      
      
      
      

      <author>
          <name>Akas</name>
        
        
      </author>

      

      
        <category term="CI" />
      

      
        <summary type="html">Branch Git을 초기화 명령을 통해, master branch가 생성된다. 개발중에 새롭게 구현하거나 코드를 작성할 경우, 각각의 기능을 Feature라고 부른다. 각각에 새로운 branch를 만들어서, 개별적으로 개발을 진행하고, master branch에 merge를 하여, 협업을 이루어 나간다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JAVA의 Iterator와 enumerate 정리</title>
      <link href="/Synchronous-Asychronous" rel="alternate" type="text/html" title="JAVA의 Iterator와 enumerate 정리" />
      <published>2019-10-02T09:00:00+00:00</published>
      <updated>2019-10-02T09:00:00+00:00</updated>
      <id>/Synchronous-Asychronous</id>
      <content type="html" xml:base="/Synchronous-Asychronous">&lt;h1 id=&quot;synchronous동기-vs-asynchronous비동기&quot;&gt;Synchronous(동기) VS Asynchronous(비동기)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;동기(Synchronous)는 어떤 작업이 실행되고, 그 작업이 완료될 때까지 다른 작업을 수행할 수가 없다. 이전의 작업이 완료되어야, 다음의 작업을 수행할 수 있다.&lt;/li&gt;
  &lt;li&gt;하지만 비동기(Asynchronous)는 하나의 작업 수행이 완료되지 않아도, 기다리지 않고 다음 작업을 실행한다. 다만 이전부터 수행하고 있던 작업들이 끝나면, 신호를 알려준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;asynchronous-programming-비동기-프로그래밍과-asyncioasyncio&quot;&gt;Asynchronous programming (비동기 프로그래밍)과 AsyncioAsyncio&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;AsyncioAsyncio는 async/await 문법을 사용해 동시성(Concurrent) 코드를 사용할 수 있게 해주는 라이브러리이다.&lt;/li&gt;
  &lt;li&gt;대표적인 장점으로는 시간이 오래 걸리는 작업을 실행했을 때, 결과를 기다리지 않고, 다음 작업을 실행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;java-iterator&quot;&gt;Java Iterator&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Iterator는 반복자라는 뜻으로, Iterator 인터페이스는 자료를 얻어내는데 사용된다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;iterator() 메소드는 컬렉션(Collection) 자료형이라면 관계없이 사용가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;For문을 통해 충분히 자료들을 꺼내올 수 있는데, 굳이 Iterator를 사용하는 이유가 무엇일까?&lt;/li&gt;
  &lt;li&gt;Ans) ArrayList에 담긴 데이터를 Set으로 옮겼다면, 일반적으로 출력문까지 전면 수정이 필요하지만, Iterator는 데이터를 빼오는 방식을 표준화하는데 목적이 있기 때문에, 코드의 재활용이 가능하다(다형성)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iterator-인터페이스에서-사용되는-메소드&quot;&gt;Iterator 인터페이스에서 사용되는 메소드&lt;/h2&gt;
&lt;h3 id=&quot;hasnext&quot;&gt;hasNext()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;뒤에 남은 데이터가 있다면 True, 없다면 False를 반환한다. while 루프를 통한 제어처리시 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;next&quot;&gt;next()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;자료구조의 다음 데이터를 반환하여, 다음 객체의 레퍼런스를 얻는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;remove&quot;&gt;remove()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;현재 조회하는 객체의 레퍼런스를 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;enumeration&quot;&gt;Enumeration&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Enumeration은 Iterator에서 remove() 메소드만 빠지고, 이름만 다를 뿐 사용법은 같다. (Iterator의 구버전)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;enumeration의-메소드&quot;&gt;Enumeration의 메소드&lt;/h2&gt;
&lt;h3 id=&quot;hasmoreelements&quot;&gt;hasMoreElements()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Iterator의 .hasNext()와 같은 기능이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nextelement&quot;&gt;nextElement()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Iterator의 next()와 같은 기능이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;listiterator&quot;&gt;ListIterator&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;ListIterator는 Iterator를 상속받아서 기능을 추가한 것이다.&lt;/li&gt;
  &lt;li&gt;컬렉션의 요소에 접근할 때, Iterator는 단방향으로만 이동할 수 있지만, ListIterator는 양방향으로 이동이 가능하다는 장점이 있다.&lt;/li&gt;
  &lt;li&gt;ArrayList나 LinkedList처럼 List 인터페이스를 구현한 컬렉션 클래스에서만 사용이 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fail-fast-방식&quot;&gt;Fail-Fast 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Iterator를 이용해서 순차적으로 접근하고 있는 도중 다른 곳에서 해당 컬렉션에 데이터를 추가하거나 삭제하는 등의 작업이 일어난다면, ConcurrentModificationException이 발생하게 하는 방식
(Java 1.2 부터 지원)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Enumeration은 컬렉션의 집합을 통째로 복사해서(Snapshot) 사용하기 때문에 Fail-Fast를 지원하지 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Iterator는 데이터의 안정성을 보장한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Akas</name>
        
        
      </author>

      

      
        <category term="JAVA" />
      

      
        <summary type="html">Synchronous(동기) VS Asynchronous(비동기) 동기(Synchronous)는 어떤 작업이 실행되고, 그 작업이 완료될 때까지 다른 작업을 수행할 수가 없다. 이전의 작업이 완료되어야, 다음의 작업을 수행할 수 있다. 하지만 비동기(Asynchronous)는 하나의 작업 수행이 완료되지 않아도, 기다리지 않고 다음 작업을 실행한다. 다만 이전부터 수행하고 있던 작업들이 끝나면, 신호를 알려준다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Parallel SSH</title>
      <link href="/PSSH" rel="alternate" type="text/html" title="Parallel SSH" />
      <published>2019-09-24T09:00:00+00:00</published>
      <updated>2019-09-24T09:00:00+00:00</updated>
      <id>/PSSH</id>
      <content type="html" xml:base="/PSSH">&lt;p&gt;다수의 타깃서버에 동일한 명령, 파일복제 등을 수행할때 PSSH, PSCP 등을 활용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;명령어-설명&quot;&gt;명령어 설명&lt;/h2&gt;
&lt;p&gt;PSSH(Parallel-SSH) : 여러 대의 서버에 동일한 명령어를 반복 적용할 수 있는 명령어
PSCP(Parallel-SCP) : 여러 대의 서버에 동일한 파일을 반복하여 복사할 수 있는 명령어
Usage: pssh/pscp (options) command
Options
-i : 결과 출력
-h : 호스트 파일 불러오기
-H : 목적지 주소 기재(ip, hostname, domain 입력), 2개 이상의 서버에 명령할 경우 띄어주기로 구분&lt;/p&gt;

&lt;h2 id=&quot;pssh-예제&quot;&gt;PSSH 예제&lt;/h2&gt;
&lt;p&gt;3.1 PSSH를 활용하여, 여러 서버의 비밀번호 변경하기
타깃 서버 리스트 작성 (-h 옵션 사용시)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동시에 명령을 수행 할 서버의 정보를 등록해준다(4가지 방식 가능)&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# ip:port 형식&lt;/span&gt;
0.0.0.1:1111
0.0.0.2:1111

&lt;span class=&quot;c&quot;&gt;# hostname:port 형식&lt;/span&gt;
hostname1:1111
hostname2:1111

&lt;span class=&quot;c&quot;&gt;# IP (사용자가 직접 SSH 서비스의 포트를 설정하면, 포트명을 생략하여 사용할 수 있다.)&lt;/span&gt;
0.0.0.1
0.0.0.2

&lt;span class=&quot;c&quot;&gt;# HostName&lt;/span&gt;
hostname1
hostname2&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;hosts에 등록 된 여러 서버의 비밀번호를 한번에 변경할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;호스트-리스트에-작성된-타깃서버들에-동일하게-password-변경-적용&quot;&gt;호스트 리스트에 작성된 타깃서버들에 동일하게 PASSWORD 변경 적용&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;pssh &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; hosts.list &lt;span class=&quot;s2&quot;&gt;&quot;echo 'PASSWORD' | sudo passwd --stdin hdfs&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;32-pscp로-파일-배포하기&quot;&gt;3.2 PSCP로 파일 배포하기&lt;/h2&gt;
&lt;p&gt;PSCP예시 : pscp [OPTIONS] 로컬파일의위치 복제할위치
PSCP 명령어는 PSSH 명령어와는 달리, “sudo” 명령어 사용에 제약(권한 제한)이 있어 /etc/hosts로 바로 이동을 시킬 수 없어 (pscp로 복제가능한 경로인) /home/hdfs에 우선 복사한 후, 옮기는 방식을 사용한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# 호스트 리스트에 작성된 타깃서버들에 파일복제 수행&lt;/span&gt;
pscp &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; hosts.list /etc/hosts /home/hdfs


/etc/hosts에 옮겨준다.

pssh &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; hosts.list &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;mv /home/hdfs/hosts /etc/hosts&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content>

      
      
      
      
      

      <author>
          <name>Akas</name>
        
        
      </author>

      

      
        <category term="Linux" />
      

      
        <summary type="html">다수의 타깃서버에 동일한 명령, 파일복제 등을 수행할때 PSSH, PSCP 등을 활용할 수 있다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Git Workflow</title>
      <link href="/git" rel="alternate" type="text/html" title="Git Workflow" />
      <published>2019-09-19T09:00:00+00:00</published>
      <updated>2019-09-19T09:00:00+00:00</updated>
      <id>/git</id>
      <content type="html" xml:base="/git">&lt;h1 id=&quot;svn과-git-차이점-요약&quot;&gt;SVN과 Git 차이점 요약&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;저장소의 위치가 다르며, 로컬 저장소가 존재한다.(분산 처리, 안전성, 빠른 속도)&lt;/li&gt;
  &lt;li&gt;커밋 이전에 스테이지 영역에 추가하는 과정이 존재(커밋 대상의 분리)&lt;/li&gt;
  &lt;li&gt;각각의 버전을 스냅샷으로 저장&lt;/li&gt;
  &lt;li&gt;스냅샷이 존재하기 때문에 브랜치도 자유롭게 생성 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;git의-주요-명령어-정리&quot;&gt;Git의 주요 명령어 정리&lt;/h1&gt;

&lt;h2 id=&quot;새로운-저장소-만들기&quot;&gt;새로운 저장소 만들기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;폴더를 만들고 그 안에서 새로운 git 저장소(.git)를 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git init&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;변경내용-확정하기&quot;&gt;변경내용 확정하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스테이징(Staging) 영역에 추가 된 변경 내용을 확정하기 위해, Commit 명령어를 이용&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;DESCRIPTION&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;변경-내용-발행하기&quot;&gt;변경 내용 발행하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;원격 저장소에 변경 내용을 올리는 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git push origin master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;기존의 remote가 아닌, 원격 저장소의 주소를 바꿔서 발행하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git remote add origin &amp;lt;원격서버주소&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h1 id=&quot;저장소-받아오기&quot;&gt;저장소 받아오기&lt;/h1&gt;
&lt;h2 id=&quot;로컬-저장소local-repository에-복제하기&quot;&gt;로컬 저장소(Local repository)에 복제하기&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone &lt;span class=&quot;s2&quot;&gt;&quot;/path&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;원격-서버의-저장소를-복제하기&quot;&gt;원격 서버의 저장소를 복제하기&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone 사용자명@호스트:/원격/저장소/경로&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;브랜치-관리하기&quot;&gt;브랜치 관리하기&lt;/h2&gt;

&lt;h3 id=&quot;브랜치-만들기&quot;&gt;브랜치 만들기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;develop이라는 이름의 브랜치를 생성한 후, 해당 디렉토리로 이동&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git checkout &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; develop&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;다시 Master로 돌아오기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git checkout master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;갱신하고-병합하기&quot;&gt;갱신하고 병합하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;로컬 저장소를 원격 저장소에 맞추어서 업데이트 및 갱신하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git pull&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;다른 브랜치의 변경 내용을 현재 브랜치에 병합하기 (현재 Branch 폴더 내에서 명령어를 수행)&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git merge &amp;lt;Branch 이름&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;브랜치-삭제-및-원격-저장소-전송&quot;&gt;브랜치 삭제 및 원격 저장소 전송&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;develop 브랜치를 삭제하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git branch &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; develop&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;원격 저장소로 브랜치 전송하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git push origin develop&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;변경-내용-되돌리기&quot;&gt;변경 내용 되돌리기.&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;한 단계 전 상태로 돌아가기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git reset HEAD~1&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;해당 커밋을 되돌리는 커밋을 새로 생성하기&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git revert&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;해당 정리는 Aria(In Suk) Kim님의 Git-Workflow를 참고하여, 작성한 포스트입니다.
참조 url : https://www.slideshare.net/shoo7830/gitworkflow-170728162&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Akas</name>
        
        
      </author>

      

      
        <category term="CI" />
      

      
        <summary type="html">SVN과 Git 차이점 요약 저장소의 위치가 다르며, 로컬 저장소가 존재한다.(분산 처리, 안전성, 빠른 속도) 커밋 이전에 스테이지 영역에 추가하는 과정이 존재(커밋 대상의 분리) 각각의 버전을 스냅샷으로 저장 스냅샷이 존재하기 때문에 브랜치도 자유롭게 생성 가능</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JAVA의 다형성(Polymorphism)과 동적바인딩</title>
      <link href="/Polymorphism_Dynamic_Binding" rel="alternate" type="text/html" title="JAVA의 다형성(Polymorphism)과 동적바인딩" />
      <published>2019-09-17T09:00:00+00:00</published>
      <updated>2019-09-17T09:00:00+00:00</updated>
      <id>/Polymorphism_Dynamic_Binding</id>
      <content type="html" xml:base="/Polymorphism_Dynamic_Binding">&lt;h1 id=&quot;다형성&quot;&gt;다형성&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;“객체지향”에는 4가지 중요한 개념이 있다. 추상화, 캡슐화, 상송 그리고 다형성이다.&lt;/li&gt;
  &lt;li&gt;아래의 코드를 통해, 다형성 및 동적 바인딩의 개념을 살펴보자.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Polymorphism&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Person&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Student&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;참조 변수 student는 Person 객체를 참조하고 있다. 따라서, Person 내의 show() 메소드가 호출이 되어야하지만, 동적바인딩을 통해 런타임 시점에 객체 타입을 기준으로 실행될 함수를 호출한다.
즉 실행되는 시점에서는  Student 객체가 생성되어, 해당 객체의 show() 함수를 호출한다.&lt;/p&gt;

&lt;p&gt;정리하자면, 다형성이 적용될 때, 참조 변수 student는 컴파일 시점과 런타임 시점에서 참조하는 함수가 다른 것이다.&lt;/p&gt;

&lt;p&gt;게시글 참조 : https://brunch.co.kr/@mystoryg/60&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Akas</name>
        
        
      </author>

      

      
        <category term="Java" />
      

      
        <summary type="html">다형성 “객체지향”에는 4가지 중요한 개념이 있다. 추상화, 캡슐화, 상송 그리고 다형성이다. 아래의 코드를 통해, 다형성 및 동적 바인딩의 개념을 살펴보자.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Stack 과 Queue 정리</title>
      <link href="/Stack_Queue" rel="alternate" type="text/html" title="Stack 과 Queue 정리" />
      <published>2019-09-11T09:00:00+00:00</published>
      <updated>2019-09-11T09:00:00+00:00</updated>
      <id>/Stack_Queue</id>
      <content type="html" xml:base="/Stack_Queue">&lt;h1 id=&quot;stack&quot;&gt;Stack&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;한 쪽 끝에서만 자료를 넣고 뺄 수 있는 자료 구조.&lt;/li&gt;
  &lt;li&gt;마지막으로 넣은 것이 가장 먼저 나오기 때문에 Last In First Out (LIFO) 라고 한다.&lt;/li&gt;
  &lt;li&gt;“스택”에서 데이터가 들어가고 나가는 곳을 “한 지점”에 고정을 시켜놓고, 명령어를 수행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;stack-명령어-정리&quot;&gt;Stack 명령어 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;push : 스택에 자료를 넣는 연산&lt;/li&gt;
  &lt;li&gt;pop : 스택에 자료를 빼는 연산&lt;/li&gt;
  &lt;li&gt;top : 스택의 가장 위에 있는 자료를 보는 연산&lt;/li&gt;
  &lt;li&gt;empty : 스택이 비어있는지 아닌지를 알아보는 연산&lt;/li&gt;
  &lt;li&gt;size : 스택에 저장되어 있는 자료의 개수를 알아보는 연산&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;대표-문제-유형&quot;&gt;대표 문제 유형&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;괄호 문제(짝 맞추기 문제)&lt;/li&gt;
  &lt;li&gt;스택 수열&lt;/li&gt;
  &lt;li&gt;단어 뒤집기&lt;/li&gt;
  &lt;li&gt;에디터 문제&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;queue&quot;&gt;Queue&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;한 쪽 끝에서만 자료를 넣고, 다른 한 쪽 끝에서만 뺄 수 있는 자료 구조&lt;/li&gt;
  &lt;li&gt;먼저 넣은 것이 가장 먼저 나오기 때문에 First In First Out(FIFO) 라고 한다.&lt;/li&gt;
  &lt;li&gt;삭제 연산은 Begin 쪽에, 삽입 연산은 End 쪽에서 이루어진다.&lt;/li&gt;
  &lt;li&gt;C++의 경우에는 STL의 queue를 사용하고, Java의 경우에는 java.util.Queue를 사용하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;queue-명령어-정리&quot;&gt;Queue 명령어 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;push : 큐에 자료를 넣는 연산&lt;/li&gt;
  &lt;li&gt;pop : 큐에서 자료를 빼는 연산&lt;/li&gt;
  &lt;li&gt;front : 큐의 가장 앞에 있는 자료를 보는 연산&lt;/li&gt;
  &lt;li&gt;back : 큐의 가장 뒤에 있는 자료를 보는 연산&lt;/li&gt;
  &lt;li&gt;empty : 큐가 비어있는지 아닌지를 알아보는 연산&lt;/li&gt;
  &lt;li&gt;size : 큐에 저장되어있는 자료의 개수를 알아보는 연산&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;대표-문제-유형-1&quot;&gt;대표 문제 유형&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;조세퍼스 문제&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;deque-덱&quot;&gt;Deque (덱)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;양 끝에서만 자료를 넣고 양 끝에서 뺄 수 있는 자료구조&lt;/li&gt;
  &lt;li&gt;Double-ended queue의 약자&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;deque-명령어-정리&quot;&gt;Deque 명령어 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;push_front : 큐에 자료를 넣는 연산&lt;/li&gt;
  &lt;li&gt;pop : 큐에서 자료를 넣는 연산&lt;/li&gt;
  &lt;li&gt;front : 큐의 가장 앞에 있는 자료를 보는 연산&lt;/li&gt;
  &lt;li&gt;back : 큐의 가장 뒤에 있는 자료를 보는 연산&lt;/li&gt;
  &lt;li&gt;empty : 큐가 비어있는지 아닌지를 알아보는 연산&lt;/li&gt;
  &lt;li&gt;size : 큐에 저장되어 있는 자료의 개수를 알아보는 연산&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Akas</name>
        
        
      </author>

      

      
        <category term="DS" />
      

      
        <summary type="html">Stack 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 자료 구조. 마지막으로 넣은 것이 가장 먼저 나오기 때문에 Last In First Out (LIFO) 라고 한다. “스택”에서 데이터가 들어가고 나가는 곳을 “한 지점”에 고정을 시켜놓고, 명령어를 수행한다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JAVA의 length, length(), size 비교</title>
      <link href="/Size_Length" rel="alternate" type="text/html" title="JAVA의 length, length(), size 비교" />
      <published>2019-09-11T09:00:00+00:00</published>
      <updated>2019-09-11T09:00:00+00:00</updated>
      <id>/Size_Length</id>
      <content type="html" xml:base="/Size_Length">&lt;h1 id=&quot;java의-length-length-size-사용-및-비교&quot;&gt;JAVA의 LENGTH, LENGTH(), SIZE 사용 및 비교&lt;/h1&gt;

&lt;h2 id=&quot;length&quot;&gt;length&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;arrays (int[], double[], String[]) : 배열의 길이를 알려 할때 사용한다.&lt;/li&gt;
  &lt;li&gt;메소드가 아니므로, Object로 사용하지 않는다. 따라서 오직 배열에서만 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;length-1&quot;&gt;length()&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;String related Object (String, StringBuilder etc) : 이것은 문자열의 길이를 알고자 할때 사용된다.&lt;/li&gt;
  &lt;li&gt;스트링은 배열이 아니므로, .length를 사용할 수 없으며, 컬렉션 또한 아니기 때문에, .size() 도 사용할 수 없다. 이를 위해 length()가 설계되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;size&quot;&gt;size()&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Collection Object (ArrayList, Set etc) : 컬렉션 타입의 길이를 확인할때 사용된다.&lt;/li&gt;
  &lt;li&gt;메소드이므로, Collection에 사용될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;지역변수-및-전역변수-신중하게-사용하기&quot;&gt;지역변수 및 전역변수 신중하게 사용하기.&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;지역 변수와 전역 변수를 구분하는 기준은, 변수를 블록 내(if, for 구문)에서만 사용가능하느냐 아니면 전체에서 사용 가능하느냐의 차이.&lt;/li&gt;
  &lt;li&gt;전역 변수는 블록 내에서 모두 사용가능하지만, 지역 변수로 활용이 되고 있는 부분이 블록 밖에서는 Compile 오류가 발생한다.&lt;/li&gt;
  &lt;li&gt;전역 변수는 함수 밖에서 선언하며, 어디에서든지 접근 가능한 변수.&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Akas</name>
        
        
      </author>

      

      
        <category term="JAVA" />
      

      
        <summary type="html">JAVA의 LENGTH, LENGTH(), SIZE 사용 및 비교</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JAVA의 length, length(), size 비교</title>
      <link href="/%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98Versus%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98" rel="alternate" type="text/html" title="JAVA의 length, length(), size 비교" />
      <published>2019-09-11T09:00:00+00:00</published>
      <updated>2019-09-11T09:00:00+00:00</updated>
      <id>/%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98Versus%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98</id>
      <content type="html" xml:base="/%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98Versus%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98">&lt;h1 id=&quot;지역변수-및-전역변수-신중하게-사용하기&quot;&gt;지역변수 및 전역변수 신중하게 사용하기.&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;지역 변수와 전역 변수를 구분하는 기준은, 변수를 블록 내(if, for 구문)에서만 사용가능하느냐 아니면 전체에서 사용 가능하느냐의 차이.&lt;/li&gt;
  &lt;li&gt;전역 변수는 블록 내에서 모두 사용가능하지만, 지역 변수로 활용이 되고 있는 부분이 블록 밖에서는 Compile 오류가 발생한다.&lt;/li&gt;
  &lt;li&gt;전역 변수는 함수 밖에서 선언하며, 어디에서든지 접근 가능한 변수.&lt;/li&gt;
  &lt;li&gt;지역 변수는 함수 내에서 선언하며 블록 내에서만 접근 가능한 변수.&lt;/li&gt;
  &lt;li&gt;단 지역변수는 선언한 위치에 따라 접근할 수 있는 (사용할 수 있는) 범위가 달라지기도 한다.&lt;/li&gt;
  &lt;li&gt;일반적인 프로그래밍에서는 곡 필요하지 않다면, 전역 변수는 잘 사용하지 않는다.&lt;/li&gt;
  &lt;li&gt;지역 변수는 함수가 끝나거나 블록을 벗어나면 메모리에서 소멸되는데, 전역 변수는 계속 살아남아있어, 메모리 낭비를 초래할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;problem_solving에서-컴파일-오류가-발생했던-부분&quot;&gt;Problem_Solving에서 컴파일 오류가 발생했던 부분&lt;/h1&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Serial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9600&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Serial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Serial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; - &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Serial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;결론: 전역 변수와 지역 변수를 구분하려고 하였으나, 변수 a를 이미 전역 변수로 선언을 하였는데, 지역 변수를 한번 더 선언을 하여 오류 발생.&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Akas</name>
        
        
      </author>

      

      
        <category term="JAVA" />
      

      
        <summary type="html">지역변수 및 전역변수 신중하게 사용하기. 지역 변수와 전역 변수를 구분하는 기준은, 변수를 블록 내(if, for 구문)에서만 사용가능하느냐 아니면 전체에서 사용 가능하느냐의 차이. 전역 변수는 블록 내에서 모두 사용가능하지만, 지역 변수로 활용이 되고 있는 부분이 블록 밖에서는 Compile 오류가 발생한다. 전역 변수는 함수 밖에서 선언하며, 어디에서든지 접근 가능한 변수. 지역 변수는 함수 내에서 선언하며 블록 내에서만 접근 가능한 변수. 단 지역변수는 선언한 위치에 따라 접근할 수 있는 (사용할 수 있는) 범위가 달라지기도 한다. 일반적인 프로그래밍에서는 곡 필요하지 않다면, 전역 변수는 잘 사용하지 않는다. 지역 변수는 함수가 끝나거나 블록을 벗어나면 메모리에서 소멸되는데, 전역 변수는 계속 살아남아있어, 메모리 낭비를 초래할 수 있다.</summary>
      

      
      
    </entry>
  
</feed>
